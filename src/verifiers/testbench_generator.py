"""
Testbench & Measurement Library - 測試平台與量測套件
自動生成測試平台並執行各種電路量測
"""

import json
import re
from typing import Dict, Any, List, Tuple, Optional
from dataclasses import dataclass
from enum import Enum
import numpy as np
import pandas as pd

class MeasurementType(Enum):
    AC_ANALYSIS = "ac_analysis"
    TRANSIENT = "transient"
    NOISE = "noise"
    THD = "thd"
    SFDR = "sfdr"
    PSRR = "psrr"
    CMRR = "cmrr"
    INL_DNL = "inl_dnl"
    ENOB = "enob"
    STARTUP = "startup"
    LOOP_GAIN = "loop_gain"

@dataclass
class MeasurementResult:
    measurement_type: MeasurementType
    value: float
    unit: str
    frequency: Optional[float] = None
    condition: Optional[str] = None
    pass_fail: bool = True
    target_value: Optional[float] = None
    tolerance: Optional[float] = None

@dataclass
class TestbenchConfig:
    name: str
    measurement_types: List[MeasurementType]
    simulation_time: float
    temperature: float
    vdd: float
    corners: List[str]
    monte_carlo_runs: int = 0

class TestbenchGenerator:
    """測試平台生成器"""
    
    def __init__(self, pdk_config: Dict[str, Any]):
        self.pdk_config = pdk_config
        self.simulation_engine = pdk_config['simulation']['default_engine']
        
        # 量測模板
        self.measurement_templates = {
            MeasurementType.AC_ANALYSIS: self._ac_analysis_template,
            MeasurementType.TRANSIENT: self._transient_template,
            MeasurementType.NOISE: self._noise_template,
            MeasurementType.THD: self._thd_template,
            MeasurementType.PSRR: self._psrr_template,
            MeasurementType.CMRR: self._cmrr_template,
            MeasurementType.INL_DNL: self._inl_dnl_template,
            MeasurementType.ENOB: self._enob_template,
            MeasurementType.STARTUP: self._startup_template,
            MeasurementType.LOOP_GAIN: self._loop_gain_template
        }
    
    def generate_testbench(self, circuit_netlist: str, 
                          requirements: Dict[str, Any],
                          measurement_types: List[MeasurementType]) -> str:
        """
        生成完整的測試平台
        
        Args:
            circuit_netlist: 電路 netlist
            requirements: 電路需求規格
            measurement_types: 要執行的量測類型
            
        Returns:
            完整的測試平台 netlist
        """
        testbench = f"""* Testbench for Circuit Verification
* Generated by EDA-Accelerater
* Requirements: {json.dumps(requirements, indent=2)}

"""
        
        # 添加電路 netlist
        testbench += circuit_netlist + "\n\n"
        
        # 添加測試信號和量測
        for meas_type in measurement_types:
            if meas_type in self.measurement_templates:
                testbench += self.measurement_templates[meas_type](requirements)
                testbench += "\n"
        
        # 添加分析指令
        testbench += self._generate_analysis_commands(measurement_types, requirements)
        
        return testbench
    
    def _ac_analysis_template(self, requirements: Dict[str, Any]) -> str:
        """AC 分析模板"""
        gbw_target = requirements.get('gbw_hz', 100e6)
        pm_target = requirements.get('pm_deg', 60)
        
        return f"""* AC Analysis for GBW and PM
.measure ac gbw when vdb(out)=0
.measure ac pm find vp(out) when vdb(out)=0
.measure ac av_dc find vdb(out) at=1
.measure ac av_1mhz find vdb(out) at=1e6

* AC analysis
.ac dec 100 1 {gbw_target*10:.0f}
"""
    
    def _transient_template(self, requirements: Dict[str, Any]) -> str:
        """暫態分析模板"""
        fs = requirements.get('fs_hz', 100e6)
        sim_time = 10 / fs  # 10 個週期
        
        return f"""* Transient Analysis for Slew Rate and Settling
.measure tran slew_rate find slope(v(out)) when v(out)=0.1*max(v(out))
.measure tran settling_time find time when v(out)=0.99*max(v(out))
.measure tran overshoot find max(v(out))-max(v(out))*0.99

* Transient analysis
.tran {sim_time/1000:.0f}p {sim_time:.0f}u
"""
    
    def _noise_template(self, requirements: Dict[str, Any]) -> str:
        """雜訊分析模板"""
        return f"""* Noise Analysis
.measure noise noise_total find onoise
.measure noise noise_1khz find onoise at=1e3
.measure noise noise_1mhz find onoise at=1e6
.measure noise noise_10mhz find onoise at=10e6

* Noise analysis
.noise v(out) vin dec 10 1 1e9
"""
    
    def _thd_template(self, requirements: Dict[str, Any]) -> str:
        """THD 分析模板"""
        fs = requirements.get('fs_hz', 100e6)
        fin = fs / 100  # 輸入頻率為採樣頻率的 1/100
        
        return f"""* THD Analysis
.measure tran thd find thd(v(out)) from={1/fin:.0f}u to={10/fin:.0f}u
.measure tran thd_db find 20*log10(thd(v(out))) from={1/fin:.0f}u to={10/fin:.0f}u

* Input sine wave
Vin in 0 sin(0 0.5 {fin:.0f} 0 0 0)
"""
    
    def _psrr_template(self, requirements: Dict[str, Any]) -> str:
        """PSRR 分析模板"""
        vdd = requirements.get('vdd_v', 1.2)
        
        return f"""* PSRR Analysis
.measure ac psrr_db find vdb(out)/vdb(vdd) at=1e3
.measure ac psrr_1mhz find vdb(out)/vdb(vdd) at=1e6
.measure ac psrr_10mhz find vdb(out)/vdb(vdd) at=10e6

* VDD modulation
VDD_mod vdd_mod 0 {vdd} ac 0.1
"""
    
    def _cmrr_template(self, requirements: Dict[str, Any]) -> str:
        """CMRR 分析模板"""
        return f"""* CMRR Analysis
.measure ac cmrr_db find vdb(out)/vdb(vcm) at=1e3
.measure ac cmrr_1mhz find vdb(out)/vdb(vcm) at=1e6
.measure ac cmrr_10mhz find vdb(out)/vdb(vcm) at=10e6

* Common mode input
Vcm_mod vcm_mod 0 0.6 ac 0.1
"""
    
    def _inl_dnl_template(self, requirements: Dict[str, Any]) -> str:
        """INL/DNL 分析模板（用於 ADC）"""
        n_bits = requirements.get('resolution_bits', 12)
        n_codes = 2 ** n_bits
        
        return f"""* INL/DNL Analysis for {n_bits}-bit ADC
.measure tran inl_max find max(abs(inl(v(out))))
.measure tran dnl_max find max(abs(dnl(v(out))))
.measure tran inl_rms find rms(inl(v(out)))
.measure tran dnl_rms find rms(dnl(v(out)))

* Ramp input for ADC testing
Vramp in 0 pwl(0 0 1m 1.2)
"""
    
    def _enob_template(self, requirements: Dict[str, Any]) -> str:
        """ENOB 分析模板"""
        return f"""* ENOB Analysis
.measure tran enob find (snr(v(out))-1.76)/6.02
.measure tran snr_db find snr(v(out))
.measure tran sndr_db find sndr(v(out))

* Sine wave input
Vin_sine in 0 sin(0 0.5 1e6 0 0 0)
"""
    
    def _startup_template(self, requirements: Dict[str, Any]) -> str:
        """啟動分析模板"""
        return f"""* Startup Analysis
.measure tran startup_time find time when v(out)=0.99*max(v(out))
.measure tran startup_overshoot find max(v(out))-max(v(out))*0.99

* Initial conditions
.ic v(out)=0
"""
    
    def _loop_gain_template(self, requirements: Dict[str, Any]) -> str:
        """迴路增益分析模板"""
        return f"""* Loop Gain Analysis
.measure ac loop_gain_db find vdb(out)/vdb(in)
.measure ac phase_margin find vp(out)-vp(in) when vdb(out)=0
.measure ac gain_margin find vdb(out) when vp(out)-vp(in)=-180

* Break loop for analysis
Rbreak in in_break 1e-6
Vbreak in_break 0 0 ac 1
"""
    
    def _generate_analysis_commands(self, measurement_types: List[MeasurementType],
                                   requirements: Dict[str, Any]) -> str:
        """生成分析指令"""
        commands = []
        
        if MeasurementType.AC_ANALYSIS in measurement_types:
            commands.append(".ac dec 100 1 1e9")
        
        if MeasurementType.TRANSIENT in measurement_types:
            commands.append(".tran 1n 10u")
        
        if MeasurementType.NOISE in measurement_types:
            commands.append(".noise v(out) vin dec 10 1 1e9")
        
        if MeasurementType.THD in measurement_types:
            commands.append(".four 1e6 v(out)")
        
        return "\n".join(commands) + "\n\n.end\n"
    
    def parse_measurement_results(self, log_file: str) -> List[MeasurementResult]:
        """
        解析量測結果
        
        Args:
            log_file: 模擬日誌文件路徑
            
        Returns:
            量測結果列表
        """
        results = []
        
        try:
            with open(log_file, 'r') as f:
                content = f.read()
            
            # 解析各種量測結果
            results.extend(self._parse_ac_results(content))
            results.extend(self._parse_transient_results(content))
            results.extend(self._parse_noise_results(content))
            results.extend(self._parse_thd_results(content))
            
        except FileNotFoundError:
            print(f"Warning: Log file {log_file} not found")
        
        return results
    
    def _parse_ac_results(self, content: str) -> List[MeasurementResult]:
        """解析 AC 分析結果"""
        results = []
        
        # 解析 GBW
        gbw_match = re.search(r'gbw\s*=\s*([\d.e+-]+)', content, re.IGNORECASE)
        if gbw_match:
            results.append(MeasurementResult(
                measurement_type=MeasurementType.AC_ANALYSIS,
                value=float(gbw_match.group(1)),
                unit="Hz",
                condition="AC Analysis"
            ))
        
        # 解析相位邊限
        pm_match = re.search(r'pm\s*=\s*([\d.e+-]+)', content, re.IGNORECASE)
        if pm_match:
            results.append(MeasurementResult(
                measurement_type=MeasurementType.AC_ANALYSIS,
                value=float(pm_match.group(1)),
                unit="degrees",
                condition="AC Analysis"
            ))
        
        return results
    
    def _parse_transient_results(self, content: str) -> List[MeasurementResult]:
        """解析暫態分析結果"""
        results = []
        
        # 解析轉換速率
        slew_match = re.search(r'slew_rate\s*=\s*([\d.e+-]+)', content, re.IGNORECASE)
        if slew_match:
            results.append(MeasurementResult(
                measurement_type=MeasurementType.TRANSIENT,
                value=float(slew_match.group(1)),
                unit="V/s",
                condition="Transient Analysis"
            ))
        
        return results
    
    def _parse_noise_results(self, content: str) -> List[MeasurementResult]:
        """解析雜訊分析結果"""
        results = []
        
        # 解析總雜訊
        noise_match = re.search(r'noise_total\s*=\s*([\d.e+-]+)', content, re.IGNORECASE)
        if noise_match:
            results.append(MeasurementResult(
                measurement_type=MeasurementType.NOISE,
                value=float(noise_match.group(1)),
                unit="V/√Hz",
                condition="Noise Analysis"
            ))
        
        return results
    
    def _parse_thd_results(self, content: str) -> List[MeasurementResult]:
        """解析 THD 分析結果"""
        results = []
        
        # 解析 THD
        thd_match = re.search(r'thd\s*=\s*([\d.e+-]+)', content, re.IGNORECASE)
        if thd_match:
            results.append(MeasurementResult(
                measurement_type=MeasurementType.THD,
                value=float(thd_match.group(1)),
                unit="%",
                condition="THD Analysis"
            ))
        
        return results
    
    def generate_measurement_report(self, results: List[MeasurementResult],
                                   requirements: Dict[str, Any]) -> str:
        """生成量測報告"""
        report = f"""# Circuit Measurement Report
Generated by EDA-Accelerater

## Target Specifications
"""
        
        for key, value in requirements.items():
            report += f"- {key}: {value}\n"
        
        report += "\n## Measurement Results\n\n"
        
        # 按量測類型分組
        by_type = {}
        for result in results:
            if result.measurement_type not in by_type:
                by_type[result.measurement_type] = []
            by_type[result.measurement_type].append(result)
        
        for meas_type, type_results in by_type.items():
            report += f"### {meas_type.value.replace('_', ' ').title()}\n\n"
            
            for result in type_results:
                status = "✅ PASS" if result.pass_fail else "❌ FAIL"
                report += f"- **{result.condition}**: {result.value:.3e} {result.unit} {status}\n"
                
                if result.target_value:
                    report += f"  - Target: {result.target_value:.3e} {result.unit}\n"
                    if result.tolerance:
                        report += f"  - Tolerance: ±{result.tolerance*100:.1f}%\n"
            
            report += "\n"
        
        return report
    
    def export_results_csv(self, results: List[MeasurementResult], 
                          output_path: str) -> None:
        """匯出結果到 CSV"""
        data = []
        for result in results:
            data.append({
                'measurement_type': result.measurement_type.value,
                'value': result.value,
                'unit': result.unit,
                'frequency': result.frequency,
                'condition': result.condition,
                'pass_fail': result.pass_fail,
                'target_value': result.target_value,
                'tolerance': result.tolerance
            })
        
        df = pd.DataFrame(data)
        df.to_csv(output_path, index=False)

# 使用範例
if __name__ == "__main__":
    import yaml
    
    # 載入配置
    with open("config/pdk_config.yaml", 'r') as f:
        pdk_config = yaml.safe_load(f)
    
    generator = TestbenchGenerator(pdk_config)
    
    # 範例電路需求
    requirements = {
        "gbw_hz": 100e6,
        "pm_deg": 60,
        "vdd_v": 1.2,
        "resolution_bits": 12,
        "fs_hz": 100e6
    }
    
    # 範例電路 netlist
    circuit_netlist = """
* Simple OTA
M1 out in n1 0 nmos_lvt W=2.4u L=28n
M2 out bias n2 0 nmos_lvt W=2.4u L=28n
M3 n1 vcm vdd vdd pmos_lvt W=4.8u L=28n
M4 n2 vcm vdd vdd pmos_lvt W=4.8u L=28n
Mbias bias 0 vdd vdd pmos_lvt W=2.4u L=28n
Ibias bias 0 DC 20uA
VDD vdd 0 1.2
VSS 0 0 0
Vin in 0 DC 0 AC 1
Vcm vcm 0 DC 0.6
Cload out 0 1p
"""
    
    # 生成測試平台
    measurement_types = [
        MeasurementType.AC_ANALYSIS,
        MeasurementType.TRANSIENT,
        MeasurementType.NOISE,
        MeasurementType.THD
    ]
    
    testbench = generator.generate_testbench(circuit_netlist, requirements, measurement_types)
    
    # 保存測試平台
    with open("testbench.sp", "w") as f:
        f.write(testbench)
    
    print("Testbench generated successfully!")
    print("Measurement types included:", [m.value for m in measurement_types])
